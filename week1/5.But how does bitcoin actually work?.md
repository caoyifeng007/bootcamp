What does it mean to have a bitcoin?

Many people have heard of bitcoin, that’s it’s a fully digital currency, with no government to issue it and no banks needed to manage accounts and verify transactions. And also that no one really knows who invented it. And yet many people don’t know the answer to this question, at least not in full. 

To get there and to make sure the technical details underlying this answer actually feel motivated, what we’re going to is walk through step-by-step how you might have invented your own version of Bitcoin.

![](alicebobyou.png)

![](crycurrency.png)

We’ll start with you keeping track of payments with your friends using a communal ledger. And then as you start to trust your friends and the world around you less and less, and if you’re clever enough to bring in a few ideas from cryptography to help circumvent the need for trust, what you end up with is what’s called a “cryptocurrency”.

Bitcoin is just the first implemented example of a cryptocurrency, and now there are thousands more on exchanges with traditional currencies. Walking the path of inventing your own can help set the foundation for understanding some of the more recent players in the game, and recognizing when and why there’s room for different design choices. In fact, one of the reasons I chose this topic is that in last year there's been a huge amount of attention and investment and well, honestly, hype directed at these currencies.

And I'm not going to comment or speculate on the current or future exchange rates, but I think we don't agree that anyone looking to buy a cryptocurrency should really know what it is. And I don't just mean in terms of analogies with vague connections to gold-mining, I mean an actual direct description of what computers are doing when we send, receive and create cryptocurrencies.

One thing worth stressing by the way is that even though you and I will dig into the details here and that takes meaningful time, you don’t actually need to know those details if you just want to use the cryptocurrency, just like you don’t need to know the details of what happens under the hood when you swipe a credit card. 

![](systemofdecentralized.png)

Like any other digital payment there's lots of user-friendly applications that let you send and receive the currencies without thinking about what's going on. The difference is that the backbone underlying this is not a bank that verifying transactions, instead it's a clever system of decentralized trustless verification based on some of the math born in cryptography. 

But to start, I want you to actually set aside the thought of cryptocurrencies and all that just for a few minutes. We’re going to begin the story with something more down-to-earth: Ledgers and digital signatures. If you and your friends exchange money pretty frequently, you know, paying your share of the dinner bill and such, it can be inconvenient to exchange cash all the time. So you might keep a communal ledger that records all of the payments that you intend to make some point in the future.

![](communalledger.png)

You know, Alice pays Bob 20, Bob pays Charlie 40, things like that. This ledger is going to be something public and accessible to everyone, like a website where anyone can go and just add new lines. And let's say that at the end of every month, you all get together look at the list of transactions and settle up. If you spent more than you received, you put that money into the pot, and if you received more than you spent, you take that much money out.

So the protocol for being part of this very simple system might look like this: Anyone can add lines to the ledger, and at the end of every month everyone get together to and settle up. Now, one problem with a public ledger like this is that anyone can add a line, what’s to prevent Bob from going in and writing “Alice pays Bob $100” without Alice approving? How are we supposed to trust that all of these transactions are what the sender meant them to be?

![](digitalsigcomesin.png)

Well, this is where the first bit of cryptography comes in: Digital signatures. Like a handwritten signature, the idea here is that Alice should be able to add something next to that transaction, that proves that she has seen it and approved of it. And it should be infeasible for anyone else to forge that signature. 

![](pubprikeypair.png)

At first, it might seem like digital signatures shouldn’t even be possible, I mean whatever data makes up the signature can just be read and copied by a computer, so how do you prevent forgeries? Well, the way this works is that everyone generates what’s called a public key/private key pair, each of which looks like some string of bits.

The private key is sometimes also called the “secret” key, so that we can abbreviate it as "sk" while abbreviating the public key as "pk". Now, as the names suggest, the secret key is something you want to keep to yourself. In the real world, your handwritten signature looks the same no matter what document you’re signing.

![](slightlychange.png)

But a digital signatures is much stronger, because it changes for different messages. It looks like a string of ones and zeros, commonly something like 256 bits, and altering the message even slightly completely changes what the signature on that message should look like. 

Speaking a little more formally, producing a signature involves a function that depends both on the message itself and on your private key. The private key ensures that only you can produce the signature, and the fact that it depends on the message means that no one can just copy one of your signatures and then forge it on another message.

![](signverify.png)

Hand in hand with this is a second function used to verify that a signature is valid, and this is where the public key comes in to play. All it does is output T or F to indicate if this was a signature created by the private key associated with the public key you're using for the verification.

![](verifyfunction.png)

I won’t go into the details how how exactly both these functions work, but the idea is that it should be completely infeasible to find a valid signature if you don’t know the secret key. Specifically, there is no strategy better than just guessing and checking random signatures which you can check using the public key that everyone knows.

![](256bitnumber.png)

Now, think about how many signatures there are with a length of 256 bits, that's $2^{256}$  (2 to the power of 256). This is a stupidly large number, to call it astronomically large would be giving way too much credit to astronomy. In fact, I made a supplemental video devoted just to illustrating what a huge number this is.

![](confident.png)

Right here, let’s just say that when you verified a signature against a given message is valid, you can feel extremely confident that the only way someone could have produced it is they knew the secret key associated with the public key you used for verification. 

Making sure that people sign transactions on the ledger is pretty good but there's one slight loophole.

![](bobcantforge.png)

![](copymessagesignature.png)

If Alice signs a transaction like “Alice pays Bob $100”, even though Bob can’t forge Alice’s signature on new messages, he could just copy that same line as many times as he wants, I mean that message signature combination remains valid.

To get around this what we do is makes sort when you sign a transaction, the message has to also include some sort of unique id associated with that transaction. That way, if Alice pays Bob 100 multiple times, each one of those lines on the ledger requires a completely new signature.

![](protocol.png)

Alright, great, digital signatures remove a huge aspect of trust in this initial protocol. But even still, if you were to really do this, you would be relying on an honor system of a sort. Namely, you’re trusting that everyone will actually follow through and settle up in cash at the end of each month. What if, for example, Charlie racks up thousands of dollars in debt and just refuses to show up?

The only real reason to revert back to cash to settle up is some people, I’m looking at you Charlie, owe a lot of money. So maybe you have the clever idea that you never actually have to settle up in cash as long as you have some way to prevent people from spending too much more than they take in.

![](nooverspending.png)

May be what you do is start by having everyone pay 100 into the pot, and then have the first few lines of the ledger read “Alice gets 100, Bob gets 100, Charlie gets 100,etc. Now, just don’t accept any transactions when someone is spending more than they already have on the ledger.

![](invalid.png)

For example, if the first two transaction are “Charlie pays Alice 50” and “Charlie pays Bob 50”, if he were to try to add “Charlie pays You 20”, that would be invalid, as invalid as if he never signed it. Notice, this means that verifying a transaction requires knowing the full history of transactions up to that point and this is, more or less, going to be true for cryptocurrencies, though there is a little room for optimization.

![](cutconnection.png)

What’s interesting here is that this step removes the connection between the Ledger and actual physical US dollars. In theory, if everyone in the world was using this Ledger, you could live your whole life just sending and receiving money on this ledger without ever having to convert to real US dollars.

![](ledgerdollar.png)

![](exchangeLD.png)

In fact, to emphasize this point, let’s start referring to quantities on the ledger as “LedgerDollars”, or LD for short. You are of course free to exchange LedgerDollars for real US dollars, for example maybe Alice gives Bob a $10 bill in the real world in exchange for him adding and signing the transaction “Bob pays Alice 10 LedgerDollars” to this communal ledger.

But exchanges like that, they are not guaranteed by the protocol. It’s now more analogous to how you might exchange Dollars for Euros or any other currency on the open market, it’s just its own independent thing. This is the first important thing to understand about Bitcoin or any other cryptocurrency: 

What it is is a ledger?

![](whatisledger.png)

The history of transactions is the currency. Of course, with Bitcoin, money doesn’t enter the ledger with people buying in using cash, I’ll get to how new money enters the ledger in just a few minutes. But before that, there’s actually an even more significant difference between our currency system of LedgerDollars and how cryptocurrencies works.

![](whocontrols.png)

So far, I’ve said that this ledger is in some public place, like a website where anyone can add new lines. But that would require trusting a central location. Namely, who hosts that website? Who controls the rules of adding new lines? 

To remove that bit of trust, we’ll have everyone keep their own copy of the ledger. Then to make a transaction, like “Alice pays Bob 100 LedgerDollars”, you broadcast into the world for people to hear and record on their own private Ledgers. But unless we do something more, this system would absurdly bad. How can you get everyone to agree on what the right ledger is? When Bob receives the transaction “Alice pays Bob 10 LedgerDollars”, how can he be sure that everyone else received and believes that same transaction? That he’ll be able to later use those 10 LedgerDollars to make a trade with Charlie. Really, imagine yourself just listening to transactions being broadcast. How can you be sure that everyone else is recording the same transactions in the same order? Now we’ve hit on an interesting puzzle: Can you come up with a protocol for how to accept or reject transactions and in what order so that you can feel confident that anyone else in the world following the same protocol has a personal ledger that looks the same as yours? This is the problem addressed in the original Bitcoin paper. At a high level, the solution Bitcoin offers to trust whichever ledger has the most computational work put into it. I’ll take a moment to explain what exactly that means, which involves this thing called a “Cryptographic hash function”. The general idea we’ll build to is that if you use computational work as a basis for what to trust, you can make it so that fraudulent transactions and conflicting ledgers would require an infeasible amount of computation.