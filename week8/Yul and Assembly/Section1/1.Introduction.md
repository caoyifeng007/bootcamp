Hello and welcome to the course. My name is Geffrey and I'll be your instructor. First of all, congratulations on choosing to learn this topic, you can be a successful solidity developer without understanding assembly but the fact that you are interested shows you intend to master the subject, and that is commendable. So if you rarely need to use assembly, what is the point of learning it? Warren Buffett is famous for saying: Risk comes from not understanding what you are doing. He meant that in the context of financial investing, but I think it applies to programming too, especially smart contracts. It is possible to write smart contracts in solidity without a clear idea of what is going on, the compiler will keep giving you hints until your code runs. However, this is not the case when it comes to programming in assembly. If something isn't working, it's almost certainly due to a gap in your knowledge. 

Learning to program in assembly exposes where your knowledge gaps are and forces you to fill them. This will make you a better solidity programmer. After this course, you will have a much better understanding of solidity idiosyncrasies. For example, why does solidity not allow you to do **keccak256(50)** but accepts **keccak256(ab.encode(50))** and how come you can append arrays in storage but can't do that to arrays in memory? Why does solidity give you the option of having variable length arguments have type memory when calldata is more efficient.

There are some additional benefits. Whenever Ethereum goes through a major upgrade and exposes a new API, it's usually available in assembly before the solidity language gets updated. And although the solidity compiler is usually pretty smart at saving gas, if you have the optimizer turned on, there are some circumstances where using assembly will result in smaller and more efficient code. When gas costs matter a lot, it helps to have more tools available for optimization. Make no mistake, programming in assembly can be dangerous, so don't go off and start including it in production contracts right away. However, you have to start somewhere, so don't let the fear of the language stop you from learning it. I will be teaching you about the risks and dangerous side effects in this course. 

This course is for people aiming to become solidity experts. I'm not going to explain things like variable scoping, if statements, for loops, functions, cryptographic hashes and so on. If you aren't already fluid with solidity, this course will be too advanced. If you have already taken my Udemy course on gas optimization, that will help, but these courses don't depend on each other and you could take them in either order, if you have experience rogramming in C or C++ or better yet, another version of assembly, this will be a breeze. Don't let the relative brevity of this course fool you. It is extremely fast paced and dense. 

Nearly all the audio pauses have been edited out and I speak about 50% faster than most lecturers. If you find I speak too fast, feel free to slow the video down. Third, I assume that you are already a competent programmer, so I won't explain things that I believe you can easily figure out on your own. To be precise, we will be teaching yul in this course, which may or may not be considered assembly, depending on who you ask. Solidity is terminology about what constitutes assembly is a bit confusing. What actually gets executed in the Ethereum virtual machine is bytecode. This is the output of the solidity compiler and that is what is stored on the blockchain. What is confusing is that the solidity syntax uses the keyword **assembly** when you inject low level instructions into your solidity code, but that low level code is not actually quite bytecode, it's an intermediate representation language called yul, yul is just the name the designers assigned to it. Like most intermediate language, yul is designed so that the translation between yul and the actual bytecode is as 1 to 1 as possible. yul doesn't have storage variables, it doesn't handle memory for you, it doesn't have arrays and doesn't parse function arguments for you. You pretty much have to do everything step by step yourself. So buckle yourself in and let's tackle this scary subject head on.