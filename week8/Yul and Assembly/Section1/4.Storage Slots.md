Now we're going to discuss how you'll handle storage variables.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract StorageBasics {

    uint256 x;

    function setX(uint256 newVal) external {
        x = newVal;
    }
    
    function getX() external view returns (uint256){
        return x;
    }
}
```

So a traditional storage variable would look something like this: uin256 x and then we would have a function setX to a new value and it would say x is equal to newVAL and this is public, we have a getter for it, but just for the sake of completeness, I'm going to do function getX and it's going to be an external view returns a uint256 and it will return x. 

OK this contract will of course behave the way that you expect it to. Starts off as zero. But if I set it to 43, then I get 43 back. Okay. No surprises there. Okay, so how do we do this in Ule? Well, the keyword that we need to know about is s load and store. Let's see how we can read the variable. So it would be function. Let's say get x and you'll and this will be an external view returns you and 256 and we're going to have a return value over here and in assembly we will want to set this to be X. Now if you do it this way, it's not going to work because it's going to say only local variables are supported to excess storage variables use the slot, the dot slot and offset suffixes. So we're going to be learning very soon about slot and offset. Now slot is the actual memory location of where X is. So if we say return X dot slot, this is actually not going to get the value back. It's going to say where X is. So let's see what happens there. So if we relaunch this, we're going to see get X and this is going to be zero. Now this is referring to where it's stored. It's not referring to the value that's actually inside of it. So if I put five into X and then get you'll, that's still going to be zero even though X is five in it. What we actually need is to load it with s load. If you've taken my guest course before, you're probably quite familiar with this instruction. But over here what it's saying is look inside of slot zero and load the value that's inside of it. So now if I update and redeploy this and then I get X, it's going to be zero in both cases. But if I set it to nine set and now it's nine in both cases because it's loading from x, so the slot is determined sequentially. This variable is going to have slot one and this variable is going to have slot two. Just to make things simple, I'm going to set Y to be equal to three and Z to be equal to four, and so that we can look at the different slots. I'm going to make this to be get variable in general and make this up to 56 slot so that we were not just looking at X. Now, if we put slot in here, then I'm able to read from these different locations. So actually while we're at it, why don't we just make this two? How about like this more interesting? Okay, let's deploy this contract. And if we were to get zero, we expect this to be two. If we get one, we expect this to be 13. And if we get two, we expect this to be 54. Now, if we look in some random location, then it's going to be zero. It's not going to throw an error. What will happen is Etherium is just going to look to that location and storage and see that there's nothing there and return the zero value. Now setting the variable will work in reverse too. If we just allow ourselves to write to an arbitrary slot, which you absolutely should not do because that's very dangerous. But I'm just going to demonstrate it. You went to 56 value, so with Ester I'm able to write to a slot and to a value. Now I can have a convenience thing here, like why slot z dot slot and that will work. But let's just demonstrate writing it to the different slots. Whoops. Again, if we get X, we're getting two. If we get Y, we're getting 13 and Z, we're getting 54. If we were to set slot zero to be 100 and then get zero, we got 100 back. And if we set Z, which is in a slot two to be 600 and we get this, we're going to get 600 back. Now note that these s loads and stores don't have any respect for the variables that already exist. There's nothing stopping me from going to slot 200 and writing one, two, three, four in there so I can totally do this in Ule. And then when I look in slot 200, it's going to be one, two, three, four. So this is something you have to be very careful with when you are writing assembly code is that you can write to an arbitrary location and if you were to write into a location where say the owner of the contract is stored and then someone changes that to be a different owner, well then you have a very serious exploit there. In fact, to really illustrate this, I have modified the code so that there is a new variable in here called P and then a function get P. So this is inside of slot zero one, two, three over here. So if I were to run this version of the contract and I get P at zero, but if I set slot three to be let's say 22, then P is going to come back as 22 because P is hard coded to look inside of slot three or in assembly. That would be P slot which is three. Okay, let's summarize what we've learned. We have learned about S load. It gives you the value that is stored in a certain slot. We have learned about a store which allows you to store into a given slot a new value. And we have learned about the shortcut. A variable name slot. This is determined at compile time and never changes. Next, we're going to look at what happens when variables are packed. So in solidity, if you have something like this, then A and B are actually going to be inside of the same slot. And just to demonstrate that function, get slot external view, returns you in 256 slot and then we will return a slot. Oops, you can't do that. Sorry. And then we will in assembly slot is equal to a slot. So it's saying this can be pure. Remember slot is known at compile time so it's not affecting the state at all, which is why this can be pure. All right, we will deploy this and run it and get slot. So this is slot three, which makes sense zero 1 to 3. However, B is also in slot three as I will demonstrate. So I'm going to change this to be recompile and deploy. And then when I get the slot, it's still three. Okay? So if they're in the same slot, how do you load the values? Well, that's actually a good question. Let's say I set a is equal to one and B is equal to one also. And I have the mechanism to get something from here. So I from from a slot that I care about. So I will just redeploy this. And then if I were to get the variable at slot three, then I get this very strange number back. And why is that? Well, that's because under the hood we have a number with one at the end and then many, many zeros to the left. We have another one, which is quite a large number. You can get a better sense of what's going on if you do bytes 32. And you can see how it is laid out in memory. So if I redeploy this and then get what I have at slot three. Here you see the one which is corresponding to this a over here. And then I see the one over here which is corresponding to this. B I guess just to make it more clear, let's make B two and rerun that. Here we have the A at one and the B at two. So if you wanted to get A or B back, how would you? Because obviously solidity is able to access B with no problem. It doesn't see the value A and vice versa. That's where bit shifting and masks comes in. And you're going to see a lot of this when you do. You'll so we will continue with that in the next video.