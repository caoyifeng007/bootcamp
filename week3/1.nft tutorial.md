In this video we're going to build a simple NFT, now it will loosely follow the ERC721 specification (eip.ethereum.org/EIPS/eip-721), but we won't follow it exactly just for the sake of simplicity. You shouldn't use this code in production, everybody uses the OpenZeppelin library which I'll get to later and there's a good reason for that. However, if we dive into OpenZeppelin right now, there's going to be a lot of code to look at and I think it will make it harder to understand what's going on. So we'll build the core functionality by hand here and then move on to OpenZeppelin once you know enough and just use that for the rest of the course.

```solidity
contract SimpleNFT {
	mapping(uint256 => address) private _owners;
}
```

Okay, let's go um. The most important thing in an NFT is the associative array between users and the tokens that they owned. So you're always going to see something like this, a mapping from uint256 to address, and this will be private and we'll call it owners.

Now why are we going from token id to address rather than the other way around? The reason for that is because you can know in advance which token ids you're going to produce but you can't know in advance which addresses are going to own it, and you cannot iterate over mappings inside of solidity. So let's say you know that your token ids are going to be 0, 1, 2, etc, etc up until 100, then you can just loop through all of the keys here and figure out who the owners are.

But you can't do it the other way, not without storing an additional list of addresses and that's going to force the contract to store more things and be more gas heavy. So, let's uh do that and the next thing that we're going to care about is obviously, if we query the token id we want to know who owns it. Well, let's uh fulfill this specification bit by bit, so an erc721 token needs to fulfill all of these functions, which we're obviously going to study each of these in detail.

But the first thing that we care about is the owner of, we care about who owns the tokens, kind of obviously right? and that's the function ownerOf, and it's saying it needs to have this signature over here, it needs to take a token id and return the owner, which is the address, so we will do that. We will return owner's token id. Now, this leads to an interesting uh question. What, if you specify a token id that is not part of the collection, like, let's say token 101 is not part of the collection. Your this thing is going to return the 0 address, because that's what mappings do if you ask for a key that's not inside of, that hasn't been specified before, it defaults to the 0 value.

```solidity
    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @param _tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);
```

According to the specification it says, nfts assigned to the 0 address are invalid and queries about them do throw, so it should throw an exception. So what are we going to do about that specification that it should throw?

```solidity
function ownerOf(uint256 _tokenId) external view returns (address){
	require(_owners[_tokenId] != address(0), "no such token");
	return _owners[_tokenId];
}
```

Well, we can just have a require statement, right? So the required statement will cause the transaction to revert. If somebody asks for a token id that hasn't been minted yet, then we shouldn't say the 0 address owns it. It should cause the transaction to revert, so let's say require "_owners[_tokenId]" does not equal the 0 address, no such token, okay, so we fulfilled the ownerOf. Obviously this is going to return a exception each time, because there's no mechanism inside of this, contract for things to be minted. Okay, let's add that.

https://eips.ethereum.org/EIPS/eip-721

Now the interesting thing here is that the ERC721 specification doesn't really say how you should mint things. It kind of leaves that up to you. So if you actually read that part of the specification here, it says, "Creation of NFTs ("minting") and destruction of NFTs ("burning") is not included in the specification, your contract may implement these by other means. See the "event" documentation for your responsibility when creating or destroying NFTs".

```solidity
function mint(uint256 _tokenId) external {}
```

Don't worry we will get to that later, but we need to create a mechanism for minting NFTs. So let's do that. Function, mint, uint256 token id external. So, just to keep things simple for now, we're going to say anybody can mint an NFT for themselves using whatever token id they like. This is obviously an extremely bad design. We should have some restrictions around what tokenid you can put in there and restrictions around who can mint and we probably want to target the money to do that, but just for the sake of simplicity, I'm going to create a very simple mint function that gets the job done and puts tokens into existence.

```solidity
function mint(uint256 _tokenId) external {
	require(_owners[_tokenId] == address(0), "already minted");
	require(_tokenId < 100, "_tokenId too large");
	_owners[_tokenId] = msg.sender;
}
```

So what we're going to do is say owners, token id. So this is going to create a new entry inside of this mapping and set it to msg.sender, Okay. Now we do have a problem here, because we probably want to revert this if someone already minted a token, because we don't want to just overwrite token ownership. Let's say I come in and I mint token10 and I set it to my address and then you come in and then set your address to mint token10, well, you've just stolen the token from me. So let's require that the owners of the token id is equal to the 0 address. So that way, you, you can only mint token ids that have not been taken yet and just to make this more interesting, because you could really mint a wide range of token ids. Just so, most nfts have a limited supply, at least the way that they're currently used. So just for the sake of it, let's also say that you can't mint a token id bigger than 100, so we're going to require that the token id is less than 100, so everything is going to go from 0 to 99 um token id, too large, okay.

So p, this function can only be called for numbers 0 through 99, and that's going to effectively limit our supply. Now. This is not the way people normally do it, but just for the sake of simplicity, I'm going to implement it this way. Okay, so we have an ability to bring tokens into existence and a way to ask who owns them.

![](mintnft.png)![](nftaccount.png)

Let's test this out, so I'm going to compile and I'm going to deploy this, now, let's try it out. So I'm going to mint token id 7 for myself. I mint and who is the owner of token 7. Well, it's going to be 0x5 b3, which is of course, the default first address inside of the remix environment.

```solidity
    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to "".
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

Okay, that's pretty simple! Now this, of course is not interesting because once it's minted to me I just own it forever, so we need to implement an ability to transfer it. What you see here, there's actually a "safeTransferFrom" and another "safeTransferFrom" and a "transferFrom". What is the difference between all of these? Well, if you look at their different signatures, let's compare these two because they have the same function name. The difference between them is bytes. So if you wanted to initiate a transfer and send some additional information along with the transfer like, let's say "thanks for doing business", then you could put that message inside of here. But if you didn't care about that, you just say I want to transfer from this address to this address, and this is the token id that I want to move. That's what you would normally do.

So, what's the difference between "safeTransferFrom" and "transferFrom", because clearly they're, both taking the same exact parameters here, well, "safeTransferFrom" is going to first check if the recipient is a smart contract, because if you transfer an NFT to a smart contract and that smart contract does not have the ability to transfer the nft again then the nft will be stuck there and be effectively useless, so there are two mechanisms for this. The "safeTransferFrom" is more complicated because it checks if the recipient is a smart contract.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	
}
```

So for now we're going to skip that and we're going to implement "transferFrom", so let's do that, now transfer from to and token id. This is actually pretty simple. We're going to take our mapping of owners and remember the key is the token id. So this token id is going to be set to the recipient, which is "to", now hopefully you're noticing a very obvious problem with this, one is, first of all, we don't know if this actually came from this address (指"_from"), this could have been known by somebody else and also we don't want to just call anyone to be able to call this function, because you could just steal NFTs from people, I'll just call this and hey you have token seven, I'm just going to take it from you and the other thing we need to check for is: we need to check if the token id actually exists.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	// check if the token id exists
	require(_owners[_tokenId] != address(0), "token does not minted.");
	require(_owners[_tokenId] == _from, "token does not minted.");
	require(msg.sender == _from);
	
	_owners[_tokenId] = _to;
}
```

Okay, so first of all, let's check if the token id exists, we're going to require that owners of token id is not equal to the 0 address. Then we're going to require that the address "_from" is actually the owner of the token. And the other thing that we'll want to remember we don't want just anybody to call this function, so there's actually a little bit more complication to this, because you might be thinking well, the only person who's going to be calling "transferFrom" is going to be the person who owns the token, because only the owner should be able to transfer their token right. Well, yes, that's true, but there's actually an additional specification inside of ERC721 where you can allow other people to transfer tokens on their behalf If you give them the privilege to. We'll get to that in a bit, but for now, let's just keep it simple and say "from" has to be msg.sender, so require msg.sender is equal to from so this means only people who own the token are able to transfer it.

Okay this is not actually fulfilling the specification. This is wrong, but I'm not trying to be uh super close to this thing, I'm just trying to give you an idea of what's going on. So let's recompile this thing and get rid of the old one here and deploy it, okay, let's mint token4 for ourselves. We see that we are the owner of and now let's comes the transfer, so from oops, from myself and now, let's transfer the NFT to another address. Let's say this guy copy this address and to and I'm going to transfer token4 now, because if I initiate the transaction right now, I'm not initiating it from the account "from", the actual nft owner. So if I hit transact here, it's just going to fail, as you can see here, boom, can't do that you are required to be the owner okay, so our security worked here, now, let's actually switch to be the owner, and transact, okay, that succeeded.

Now, if we ask for the owner of 4 again now it's going to change to ab8, okay, what I want to do now is make sure that what we're doing is actually on track with how NFTs are actually used in the real world right now. I don't want to just keep okay we're following a spec we're building an nft. We want to build nfts that people are actually using. So let's see the relationship between the functions that we're creating here and how NFTs are used on OpenSea.

So let's go to opensea.io and let us look at the cool cats collection, cools, cool cats. Okay, now, let's see who owns this cat and when we look at details, we're going to see the contract address and the token id okay. Now I want you to remember 8696 because remember how we were minting like token4 to ourselves last time. Well, this is token8696, let's see how the relationship between what's inside of this smart contract and what we've been doing. So I'm going to open up this thing, and it's going to take me to etherscan and I am going to hit contract, read the contract and look for ownerOf, there it is, so if I put in 8696 and query it, it's going to say, the owner of this is fcfc32, something something c5e. Well, is that the actual owner of this? Well, if we go uh look at what opensea is saying, then it's going to say it's owned by nftboho and let's see this guy's ethereum address or, girl I don't actually know. So if I click down it says 0fcfc5e, which is exactly what we have here.

Okay, that's pretty cool. If you wanted to transfer this well, you cannot, because you don't own this nft, I presume, here we can see this contract fulfilling the safe transfer from and the transfer from. If so, if this was initiated, we see the same arguments that we saw earlier, the from and the to and the tokenId. All right cool. Now, of course, a very natural question is: well, where's the jpeg. Well, that is what we are going to look at. We are going to implement the token uri function and when we put in 8696 in here, whoops, then what it's going to do is give us back a resource id and it says https://coolcatsnft.com/cat/8696 and we put that into our browser and we actually get a json file back. And we get a json file back now. This might seem a little bit counterintuitive, because we thought okay wait a minute, aren't these supposed to be jpegs? Well, traditionally, how the nfts are configured nowadays is that resource url points you to a json file that allows you to put extra metadata about the about the nft. So it says it's a "blue cat" and it has a hat and the hat is "visor blue". That is where opensea, if I go back here, is getting this information: blue cat, skin hat, visor, blue and so forth. There were other traits that I didn't read off, but they're all listed there. 

Now let us look at the actual image. So if you look at the image field inside of this json file, then we can copy this and put it over here and there is the actual cat stored on ipfs. Don't worry if you don't know what ipfs is right now, that is something that we will discuss later. Now what we want to do is replicate the mechanism that this cool cats contract is doing, so that we can store jpegs. Okay. What we will need is a url, so originally cool cats was storing them inside of uh something like this, so they had something like string. Let's call it baseURL is equal to https://api.coolcatsnft.com/cat/8696. Okay, but we don't want to hard code this. We want this to be um, a number that we're going to put in there, which is going to be a number from 0 to 99, and we also are not doing the cool cats nft we're using our own. So I'm just going to say example.com/images. There's, of course, nothing there, but you get the point.

Now one thing you might be noting is hey wait a minute, couldn't we just point these jpegs to the cool cat and then copy it? Well, no, because that's not what makes nfts unique as we talked about earlier, it's the combination of the smart contract address and the token id that makes nfts unique, not the resources that they point to off chain. So we have our baseURL, next thing: we're going to want to be doing is concatenating. Well, you can't concatenate in solidity, but we want to be building a string. That's going to contain the integer in here that corresponds to our token, now, but what was the interface for getting back the url? Well, remember, when we looked back here, we were looking at, tokenURI was the function that told us where the actual image was stored, or rather, where the json was, which told us where the image was stored, and this is not a coincidence.

```solidity
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);
}
```

This is part of the ERC721 specification, so I'm going to go back there. If we look at token uri, then this is part of the interface that gives us a distinct uniform resource identifier for a given asset, and it throws token id is not valid. So this is the resource identifier which in this case is an http url or it could be an ipfs url, but don't worry about that we'll get to that later. Okay- let's paste this in here, what we want to do is return, or at least at the end of when everything is completed. If someone asks for let's say token 5, then we want to return this. So how can we go about doing this? Well, we don't want to hard code it. What we will want to do is first of all fulfill the specification and check hey is this actually existing because we don't want to return a url. If someone says uh 101, remember, 101 is not a valid token or dc a token id. So we don't want to say example.com images, slash 101, because that would be wrong. So what we were going to do is require that the owners of token id is not equal to the zero address does not exist. Now, let's return the actual string here. So I'm going to show you how to do this wrong and then I'm going to show you how to fix it. Otherwise, I'm going to just be giving you too much new code and you're going to be wondering why I'm doing it so I'm going to return a string by doing this return string. So what I'm going to do is going to be cast to a string and I'm going to say, abi dot, encode pact base url and I'm going to put the token id in there. Okay, well, first of all something breaks, it says: data location must be memory or call data for return type. So it's saying this needs to have a memory keyword in there because strings are stored in memory. Now, why on earth was the solidity code that they gave us inside of the eip specification wrong? Well, it wasn't. This is for an interface specification, it's not for the actual contract, but since we are not building an interface here, we're building the actual contract, we need to say where the string is stored in strings, are either memory or call data. Call data only applies if it's inside of the function arguments- and this is not a function argument- it's a return type. Okay, so we have this now you're going to actually see some funny results here. So if I deploy this contract and first of all, if I try to ask hey, what's the token you are for five, it's going to give me an error, it says revert here. So that's what we expected- let's mint token 5, so that we don't have that problem and then, when we get token uri back um it's empty, it's only giving us the base url what what what happened! Well uh! This is not a string. This is an integer and we are effectively trying to mix these two types together, which is just not gonna work. So if we wanted to convert this thing to a string well, ideally we would do something like to string over here, but unfortunately this is not valid solidity. We need to import a library to do this and luckily open zeppelin provides us a nice utility for that we're going to import open zeppelin to get that tostring functionality. So if I look at open zeppelin contracts on github, then we will be able to recover the path that we need for that. So if I look inside of contracts and I'm going to look inside of utils and I'm going to look at strings, and here in this library, we have a two-string utility which is going to take the un-256 and return the the string. This is actually some pretty complicated code here, so luckily we don't have to do that ourselves. Well, let's go back to remix we're going to need to remember this: we're going to import at open, zeppelin, uh, slash, contract, strings.sol and then whoops. What's going on here! Sorry, let me just comment out this broken code for now and return an empty string so that the compiler stops yelling at us now. What just happened when I did this well, if I look inside of the file explorer and then go to npm open zeppelin, then here we have strings.sol that thing from github just got dropped in here. That's what this app thing is doing like this: we're, basically just taking a shortcut and doing an npm install for open zeppelin, and then we are following the same path inside of the github in order to get the utility back so to make this dot tostring valid. What we need to do is associate uh the this library with the uint256. So if we say using strings for un256, what that is going to do is associate this library with un256. So if we call dot two string on a un-256, then that's effectively going to put that? U and 256 inside of this function argument and just give us the string back. So that's!