In this video we're going to build a simple NFT, now it will loosely follow the ERC721 specification (eip.ethereum.org/EIPS/eip-721), but we won't follow it exactly just for the sake of simplicity. You shouldn't use this code in production, everybody uses the OpenZeppelin library which I'll get to later and there's a good reason for that. However, if we dive into OpenZeppelin right now, there's going to be a lot of code to look at and I think it will make it harder to understand what's going on. So we'll build the core functionality by hand here and then move on to OpenZeppelin once you know enough and just use that for the rest of the course.

```solidity
contract SimpleNFT {
	mapping(uint256 => address) private _owners;
}
```

Okay, let's go um. The most important thing in an NFT is the associative array between users and the tokens that they owned. So you're always going to see something like this, a mapping from uint256 to address, and this will be private and we'll call it owners.

Now why are we going from token id to address rather than the other way around? The reason for that is because you can know in advance which token ids you're going to produce but you can't know in advance which addresses are going to own it, and you cannot iterate over mappings inside of solidity. So let's say you know that your token ids are going to be 0, 1, 2, etc, etc up until 100, then you can just loop through all of the keys here and figure out who the owners are.

But you can't do it the other way, not without storing an additional list of addresses and that's going to force the contract to store more things and be more gas heavy. So, let's uh do that and the next thing that we're going to care about is obviously, if we query the token id we want to know who owns it. Well, let's uh fulfill this specification bit by bit, so an erc721 token needs to fulfill all of these functions, which we're obviously going to study each of these in detail.

But the first thing that we care about is the owner of, we care about who owns the tokens, kind of obviously right? and that's the function ownerOf, and it's saying it needs to have this signature over here, it needs to take a token id and return the owner, which is the address, so we will do that. We will return owner's token id. Now, this leads to an interesting uh question. What, if you specify a token id that is not part of the collection, like, let's say token 101 is not part of the collection. Your this thing is going to return the 0 address, because that's what mappings do if you ask for a key that's not inside of, that hasn't been specified before, it defaults to the 0 value.

```solidity
    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @param _tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);
```

According to the specification it says, nfts assigned to the 0 address are invalid and queries about them do throw, so it should throw an exception. So what are we going to do about that specification that it should throw?

```solidity
function ownerOf(uint256 _tokenId) external view returns (address){
	require(_owners[_tokenId] != address(0), "no such token");
	return _owners[_tokenId];
}
```

Well, we can just have a require statement, right? So the required statement will cause the transaction to revert. If somebody asks for a token id that hasn't been minted yet, then we shouldn't say the 0 address owns it. It should cause the transaction to revert, so let's say require "_owners[_tokenId]" does not equal the 0 address, no such token, okay, so we fulfilled the ownerOf. Obviously this is going to return a exception each time, because there's no mechanism inside of this, contract for things to be minted. Okay, let's add that.

https://eips.ethereum.org/EIPS/eip-721

Now the interesting thing here is that the ERC721 specification doesn't really say how you should mint things. It kind of leaves that up to you. So if you actually read that part of the specification here, it says, "Creation of NFTs ("minting") and destruction of NFTs ("burning") is not included in the specification, your contract may implement these by other means. See the "event" documentation for your responsibility when creating or destroying NFTs".

```solidity
function mint(uint256 _tokenId) external {}
```

Don't worry we will get to that later, but we need to create a mechanism for minting NFTs. So let's do that. Function, mint, uint256 token id external. So, just to keep things simple for now, we're going to say anybody can mint an NFT for themselves using whatever token id they like. This is obviously an extremely bad design. We should have some restrictions around what tokenid you can put in there and restrictions around who can mint and we probably want to target the money to do that, but just for the sake of simplicity, I'm going to create a very simple mint function that gets the job done and puts tokens into existence.

```solidity
function mint(uint256 _tokenId) external {
	require(_owners[_tokenId] == address(0), "already minted");
	require(_tokenId < 100, "_tokenId too large");
	_owners[_tokenId] = msg.sender;
}
```

So what we're going to do is say owners, token id. So this is going to create a new entry inside of this mapping and set it to msg.sender, Okay. Now we do have a problem here, because we probably want to revert this if someone already minted a token, because we don't want to just overwrite token ownership. Let's say I come in and I mint token10 and I set it to my address and then you come in and then set your address to mint token10, well, you've just stolen the token from me. So let's require that the owners of the token id is equal to the 0 address. So that way, you, you can only mint token ids that have not been taken yet and just to make this more interesting, because you could really mint a wide range of token ids. Just so, most nfts have a limited supply, at least the way that they're currently used. So just for the sake of it, let's also say that you can't mint a token id bigger than 100, so we're going to require that the token id is less than 100, so everything is going to go from 0 to 99 um token id, too large, okay.

So p, this function can only be called for numbers 0 through 99, and that's going to effectively limit our supply. Now. This is not the way people normally do it, but just for the sake of simplicity, I'm going to implement it this way. Okay, so we have an ability to bring tokens into existence and a way to ask who owns them.

![](mintnft.png)![](nftaccount.png)

Let's test this out, so I'm going to compile and I'm going to deploy this, now, let's try it out. So I'm going to mint token id 7 for myself. I mint and who is the owner of token 7. Well, it's going to be 0x5 b3, which is of course, the default first address inside of the remix environment.

```solidity
    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to "".
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

Okay, that's pretty simple! Now this, of course is not interesting because once it's minted to me I just own it forever, so we need to implement an ability to transfer it. What you see here, there's actually a "safeTransferFrom" and another "safeTransferFrom" and a "transferFrom". What is the difference between all of these? Well, if you look at their different signatures, let's compare these two because they have the same function name. The difference between them is bytes. So if you wanted to initiate a transfer and send some additional information along with the transfer like, let's say "thanks for doing business", then you could put that message inside of here. But if you didn't care about that, you just say I want to transfer from this address to this address, and this is the token id that I want to move. That's what you would normally do.

So, what's the difference between "safeTransferFrom" and "transferFrom", because clearly they're, both taking the same exact parameters here, well, "safeTransferFrom" is going to first check if the recipient is a smart contract, because if you transfer an NFT to a smart contract and that smart contract does not have the ability to transfer the nft again then the nft will be stuck there and be effectively useless, so there are two mechanisms for this. The "safeTransferFrom" is more complicated because it checks if the recipient is a smart contract.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	
}
```

So for now we're going to skip that and we're going to implement "transferFrom", so let's do that, now transfer from to and token id. This is actually pretty simple. We're going to take our mapping of owners and remember the key is the token id. So this token id is going to be set to the recipient, which is "to", now hopefully you're noticing a very obvious problem with this, one is, first of all, we don't know if this actually came from this address (指"_from"), this could have been known by somebody else and also we don't want to just call anyone to be able to call this function, because you could just steal NFTs from people, I'll just call this and hey you have token seven, I'm just going to take it from you and the other thing we need to check for is: we need to check if the token id actually exists.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	// check if the token id exists
	require(_owners[_tokenId] != address(0), "token does not minted.");
	require(_owners[_tokenId] == _from, "token does not minted.");
	require(msg.sender == _from);
	
	_owners[_tokenId] = _to;
}
```

Okay, so first of all, let's check if the token id exists, we're going to require that owners of token id is not equal to the 0 address. Then we're going to require that the address "_from" is actually the owner of the token. And the other thing that we'll want to remember we don't want just anybody to call this function, so there's actually a little bit more complication to this, because you might be thinking well, the only person who's going to be calling "transferFrom" is going to be the person who owns the token, because only the owner should be able to transfer their token right. Well, yes, that's true, but there's actually an additional specification inside of ERC721 where you can allow other people to transfer tokens on their behalf If you give them the privilege to. We'll get to that in a bit, but for now, let's just keep it simple and say "from" has to be msg.sender, so require msg.sender is equal to from so this means only people who own the token are able to transfer it.

Okay this is not actually fulfilling the specification. This is wrong, but I'm not trying to be uh super close to this thing, I'm just trying to give you an idea of what's going on. So let's recompile this thing and get rid of the old one here and deploy it, okay, let's mint token4 for ourselves. We see that we are the owner of and now let's comes the transfer, so from oops, from myself and now, let's transfer the NFT to another address. Let's say this guy copy this address and to and I'm going to transfer token4 now, because if I initiate the transaction right now, I'm not initiating it from the account "from", the actual nft owner. So if I hit transact here, it's just going to fail, as you can see here, boom, can't do that you are required to be the owner okay, so our security worked here, now, let's actually switch to be the owner, and transact, okay, that succeeded.

Now, if we ask for the owner of 4 again now it's going to change to ab8, okay, what I want to do now is make sure that what we're doing is actually on track with how NFTs are actually used in the real world right now. I don't want to just keep okay we're following a spec we're building an nft. We want to build nfts that people are actually using. So let's see the relationship between the functions that we're creating here and how NFTs are used on OpenSea.

So let's go to opensea.io and let us look at the cool cats collection, cools, cool cats. Okay, now, let's see who owns this cat and when we look at details, we're going to see the contract address and the token id okay. Now I want you to remember 8696 because remember how we were minting like token4 to ourselves last time. Well, this is token8696, let's see how the relationship between what's inside of this smart contract and what we've been doing. So I'm going to open up this thing, and it's going to take me to etherscan and I am going to hit contract, read the contract and look for ownerOf, there it is, so if I put in 8696 and query it, it's going to say, the owner of this is fcfc32, something something c5e. Well, is that the actual owner of this? Well, if we go uh look at what opensea is saying, then it's going to say it's owned by nftboho and let's see this guy's ethereum address or, girl I don't actually know. So if I click down it says 0fcfc5e, which is exactly what we have here.

Okay, that's pretty cool. If you wanted to transfer this well, you cannot, because you don't own this nft, I presume, here we can see this contract fulfilling the safe transfer from and the transfer from. If so, if this was initiated, we see the same arguments that we saw earlier, the from and the to and the tokenId. All right cool. Now, of course, a very natural question is: well, where's the jpeg. Well, that is what we are going to look at. We are going to implement the token uri function and when we put in 8696 in here, whoops, then what it's going to do is give us back a resource id and it says https://coolcatsnft.com/cat/8696 and we put that into our browser and we actually get a json file back. And we get a json file back now. This might seem a little bit counterintuitive, because we thought okay wait a minute, aren't these supposed to be jpegs? Well, traditionally, how the nfts are configured nowadays is that resource url points you to a json file that allows you to put extra metadata about the about the nft. So it says it's a "blue cat" and it has a hat and the hat is "visor blue". That is where opensea, if I go back here, is getting this information: blue cat, skin hat, visor, blue and so forth. There were other traits that I didn't read off, but they're all listed there. 

Now let us look at the actual image. So if you look at the image field inside of this json file, then we can copy this and put it over here and there is the actual cat stored on ipfs. Don't worry if you don't know what ipfs is right now, that is something that we will discuss later. Now what we want to do is replicate the mechanism that this cool cats contract is doing, so that we can store jpegs. Okay. What we will need is a url, so originally cool cats was storing them inside of uh something like this, so they had something like string. Let's call it baseURL is equal to https://api.coolcatsnft.com/cat/8696. Okay, but we don't want to hard code this. We want this to be um, a number that we're going to put in there, which is going to be a number from 0 to 99, and we also are not doing the cool cats nft we're using our own. So I'm just going to say example.com/images. There's, of course, nothing there, but you get the point.

Now one thing you might be noting is hey wait a minute, couldn't we just point these jpegs to the cool cat and then copy it? Well, no, because that's not what makes nfts unique as we talked about earlier, it's the combination of the smart contract address and the token id that makes nfts unique, not the resources that they point to off chain. So we have our baseURL, next thing: we're going to want to be doing is concatenating. Well, you can't concatenate in solidity, but we want to be building a string. That's going to contain the integer in here that corresponds to our token, now, but what was the interface for getting back the url? Well, remember, when we looked back here, we were looking at, tokenURI was the function that told us where the actual image was stored, or rather, where the json was, which told us where the image was stored, and this is not a coincidence.

```solidity
/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);
}
```

This is part of the ERC721 specification, so I'm going to go back there. If we look at tokenURL, then this is part of the interface that gives us a distinct Uniform Resource Identifier (URI) for a given asset, and it throws token id is not valid. So this is the resource identifier which in this case is an http url or it could be an ipfs url, but don't worry about that we'll get to that later. Okay, let's paste this in here, what we want to do is return, or at least at the end of when everything is completed, if someone asks for let's say token 5, then we want to return this.

```solidity
function tokenURI(uint256 _tokenId) external view returns (string) {
	return "https://example.com/image/5"
}
```

So how can we go about doing this? Well, we don't want to hard code it. What we will want to do is first of all fulfill the specification and check hey is this actually existing because we don't want to return a url. If someone says uh 101, remember, 101 is not a valid token or dc a token id. So we don't want to say example.com images, slash 101, because that would be wrong.

```solidity
function tokenURI(uint256 _tokenId) external view returns (string) {
	require(_owners[_tokenId] != address(0), "does not exist.");
	return "https://example.com/image/5"
}
```

So what we were going to do is require that the owners of token id is not equal to the zero address, does not exist. Now, let's return the actual string here. So I'm going to show you how to do this wrong and then I'm going to show you how to fix it. Otherwise, I'm going to just be giving you too much new code and you're going to be wondering why I'm doing it, so I'm going to return a string by doing this return string. So what I'm going to do is going to be cast to a string and I'm going to say, abi.encodePacted baseURL and I'm going to put the token id in there. Okay, well, first of all something breaks, it says: data location must be memory or calldata for return type. So it's saying this needs to have a memory keyword in there because strings are stored in memory.

```solidity
string baseURL = "https://example.com/images/";

function tokenURI(uint256 _tokenId) external view returns (string memory) {
	require(_owners[_tokenId] != address(0), "does not exist.");
	return string(abi.encodePacked(baseURL, _tokenId));
}
```

Now, why on earth was the solidity code that they gave us inside of the eip specification wrong? Well, it wasn't. This is for an interface specification, it's not for the actual contract, but since we are not building an interface here, we're building the actual contract, we need to say where the string is stored in, strings are either memory or calldata. Calldata only applies if it's inside of the function arguments, and this is not a function argument, it's a return type. Okay, so we have this now you're going to actually see some funny results here.

![](mixfail.png)

So if I deploy this contract and first of all, if I try to ask hey, what's the tokenURI for 5, it's going to give me an error, it says revert here. So that's what we expected, let's mint token 5, so that we don't have that problem and then when we get tokenURI back, um it's empty, it's only giving us the baseURL, what what what happened? Well, uh! This is not a string. This is an integer and we are effectively trying to mix these two types together which is just not gonna work. So if we wanted to convert this thing to a string, well, ideally we would do something like to string over here, but unfortunately this is not valid solidity. We need to import a library to do this and luckily OpenZeppelin provides us a nice utility for that.

https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol

We're going to import OpenZeppelin to get that tostring functionality. So if I look at OpenZeppelin contracts on github, then we will be able to recover the path that we need for that. So if I look inside of contracts and I'm going to look inside of utils and I'm going to look at strings, and here in this library, we have a "toString" utility which is going to take the uint256 and return the the string. This is actually some pretty complicated code here, so luckily we don't have to do that ourselves. Well, let's go back to remix we're going to need to remember this.

```solidity
import "@openzeppelin/contracts/utils/Strings.sol";
```

![](remixnpm.png)

We're going to import "@openzeppelin/contracts/utils/Strings.sol" and then whoops what's going on here. Sorry, let me just comment out this broken code for now and return an empty string so that the compiler stops yelling at us. Now what just happened when I did this, well, if I look inside of the file explorer and then go to npm openzeppelin, then here we have strings.sol that thing from github just got dropped in here. That's what this app thing is doing like this, we're basically just taking a shortcut and doing an npm install for openzeppelin, and then we are following the same path inside of the github in order to get the utility back, so to make this ".tostring" valid. What we need to do is associate uh the this library with the uint256.

```solidity
using Strings for uint256;
```

So if we say "using Strings for uint256", what that is going to do is associate this library with un256. So if we call .toString on a uint256, then that's effectively going to put that uint256 inside of this function argument and just give us the string back. So that's I know this is throwing a bit more information at you, but you're going to see this pattern all the time so we might as well learn it now.

```solidity
function tokenURI(uint256 _tokenId) external view returns (string memory) {
	require(_owners[_tokenId] != address(0), "does not exist.");
	return string(abi.encodePacked(baseURL, _tokenId.toString(), ".jpeg");
}
```

So let's go back here and uncomment this get rid of this, and now this should work as expected. If we wanted to say jpeg at the end, then we could just say jpeg and now all of these things are going to fall together quite nicely. So I'm I compiled it by hitting uh command s on my macbook and now I'm going to erase the old contract, deploy this one and mint token 5 and get the url for token 5 and there it is https://example.com/images/5.jpeg, make that a little nicer, okay cool! So this is how we can have jpegs associated with our smart contract which is on the blockchain fully.

When you looked at this, you notice that hey wait a second. This doesn't make sense. If we only allow msg.sender to initiate the transactions, then if we buy something on opensea, how on earth is this going to work? Because if I try to buy this, I'm not the owner of this particular nft. So when I hit checkout, I'm not going to be able to move the nft out of this person's wallet into my wallet or I guess it's technically not inside of the wallet, but I don't have the authority to change this associative array over here, changing that particular nft to my address that's what happens when the ownership changes. So how can we solve this?

```solidity
    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all of `msg.sender`'s assets
    /// @dev Emits the ApprovalForAll event. The contract MUST allow
    ///  multiple operators per owner.
    /// @param _operator Address to add to the set of authorized operators
    /// @param _approved True if the operator is approved, false to revoke approval
    function setApprovalForAll(address _operator, bool _approved) external;
```

Well, according to the erc721 specification, we can have a function called setApprovalForAll which is going to enable or disable approval for a third party ("operator") to manage all of msg.sender's assets. So what that means on opensea is you can allow opensea to manage all of your assets and or at least all of your assets for a particular nft collection and that will allow them to move the nft out of your wallet and into the buyer's wallet. So we can actually uh see that in action here, so this person must have granted opensea access to... let's copy this, it must have granted opensea approval to move the asset out. 

etherscan.io/tokenapprovalchecker

![](doodle3357.png)

![](getowneraddr.png)

![](searcherc721.png)

So if we look at uh etherscan token approval, you can actually see that in action. So I'm going to put this person's address in there and if we look at erc721, okay here he has approved this doodle's asset to be controlled by opensea. Okay, now this particular approval thing is coming, excuse me, is coming from this (指setApprovalForAll方法) being set all right. 

Now, you can imagine that this is kind of dangerous, because if you allow another address to move around assets for you, then it can steal them, and this is certainly a somewhat controversial design decision for tokens, because it certainly introduces a security vulnerability and there have been token thieves because of this kind of a thing, but this is the specification and that's what we have to learn about. So let's keep going with this.

```solidity
mapping(address => mapping(address => bool)) private _operators;
```

Now, let's create a data structure that allows us to track this thing. So what it's saying is we need to be able to approve or disapprove. So what we are going to have is a mapping from address to another mapping that goes from address to boolean and we're going to call this operators. Okay, what on earth is going on here?

Well, this (指第一个address) is going to be msg.sender. This (值第二个address) is going to be the address you are approving which the example we've been using is opensea smart contract and then a boolean to say, if it's approved or not, and now we can set this, well, I need to copy over this function don't I?

```solidity
function setApprovalForAll(address _operator, bool _approved) external {
	_operators[msg.sender][_operator] = _approved;
}
```

So, let's copy this, over here, and then we are going to... then we're going to take this variable and say: msg.sender will be the first address, the operator is the one we are granting privileges to, and we will say that if they are approved or not. Now how can we actually set this inside of the transfer? Well, what we need to do is say, only the owner is allowed to transfer things, but the other thing we want to check for is if msg.sender is approved for the _from address.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	// check if the token id exists
	require(_owners[_tokenId] != address(0), "token does not minted.");
	require(_owners[_tokenId] == _from, "token does not minted.");
	// || 之后为新添加的部分
	require(msg.sender == _from || _operators[_from][msg.sender], "required to be owner");
	
	_owners[_tokenId] = _to;
}
```

So what we will do is operators from and then msg.sender and this just will return a boolean. So if this is true then this will pass. Okay, so what's going on here is saying msg.sender can obviously move their own assets, or if msg.sender is an approved operator for where the nft is coming from, then we are allowed to conduct this also. Now there is something that we need to take care of here, after it's, after this nft has been transferred, then we should set this thing back to false so because the asset is no longer owned by this person anymore.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
	// check if the token id exists
	require(_owners[_tokenId] != address(0), "token does not minted.");
	require(_owners[_tokenId] == _from, "token does not minted.");
	// || 之后为新添加的部分
	require(msg.sender == _from || _operators[_from][msg.sender], "required to be owner");
	
	_operators[_from][msg.sender] = false;
	_owners[_tokenId] = _to;
}
```

So we should just get rid of the privileges, so there's no floating privileges, so I'm going to do, operators and get from and msg.sender, then we're going to set it back to false. Okay um, what just happened. Oh I put the variables in wrong. Sorry so this is _from and this is _from also, let's see this in action.

We are going to deploy this contract and we want to set an approval, so right now I'm operating as 5b3 as usual, I'm going to mint it, and now I want to approve this address to be able to manage my all of my tokens. I'm going to copy this put that in here and this address this dd87 address can now manage all of my tokens that are owned by 5b3. Okay, so we're going to set this to true and transact, now that that is set, then we can see the operator moving the token on behalf of the original owner. So let's copy the original owner and from and let's say we're going to move it to this address, ab8 we'll copy that put it in here and we will move token 5. Now the person who can actually conduct this transaction is either the owner or the approved one. Let's do the approved one just to make this interesting and before we do that, let's see that the owner of token token5 is in fact 5b38. We conduct the transfer it goes through, and when we check the owner again it has moved to ab8.

Okay. Now, it's probably would be really handy to know if you know if an address is approved for another address, so the erc721 specification has this "isApprovedForAll" uh function over here, which is just returning the values that are inside of here (指了下setApprovalForAll方法) ,

```solidity
function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
	return _operators[_owner][_operator];
}
```

because it returns bool as you can see, so we will just return. This owner, obviously, okay so setApprovalForAll and isApprovedForAll lets you manage any nft regardless. If you wanted to give someone more granular privileges, then you could use "approve" and that will only allow it for a certain token id, so this is safer if you wanted, say a smart contract to be moving only particular token ids, there's just no reason to set to do set approval for all, because that gives you too much privileges. So we're not actually going to implement uh this one for now, because I don't want to bore you with the details and we're going to move over to OpenZeppelin fairly soon. But I just wanted to show you how erc721 gives you a mechanism to move assets that are not owned by you to another address, assuming that the original owner has given the privileges to the appropriate smart contract or wallet.

Now there is one more interesting thing that we need to cover that you may have been wondering about. You will note that opensea seems to pick up pretty well that oh there's this is tokenid 8066, 2331, 1633 and so on. So how does opensea know all of these numbers in the first place, if our contract, well, we said it could go from 0 to 99, but opensea is not going to read the source code inside of our smart contract and determine that because this is pretty arbitrarily structured right? In fact, the erc721 specification specifically says: "While some erc721 smart contracts may find it convenient to start with id 0 and simply increment by 1 for each new nft, callers shall not assume that the id numbers have any specific pattern to them and must treat the id as a 'black box'".

Ok, so how can opensea know this because there's no guarantee that the ids will be sequential, well, that is where the "events" come in handy. So whenever you conduct a transfer, you are supposed to log that event to the ethereum blockchain or log or emit an event. That means the same thing in the context of ethereum. 

![](erc721event.png)

So when you look at the actual smart contract for this, let's again go back to contract address. If we look at the events, then we are going to see a transfer from a certain address to another address and another topic, which is the token id. So there was a transfer from this address to this address, using this token id, which is written in hexadecimal, but if we convert this to decimal, we'll see it corresponds to the token id. By looking at all of the transfers that's how you are able to figure out, well, which token ids exist and "to" who owns them because remember

```solidity
mapping(uint256 => address) private _owners;
```

 if you look back here, we can once we once we know all of the token ids that exist, then we can outside of the blockchain, just keep calling ownerOf over and over again and find out which addresses own things, that's how opensea is able to know who owns each of these assets.

```solidity
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
```

Okay. So if we wanted to actually implement this ourselves properly, we can create the event like so and then emit this event.

```solidity
 function transferFrom(address _from, address _to, uint256 _tokenId) external payable {
   // check if the token id exists
   require(_owners[_tokenId] != address(0), "token does not minted.");
   require(_owners[_tokenId] == _from, "token does not minted.");
   require(msg.sender == _from || _operators[_from][msg.sender], "required to be owner");

  // 新添加部分
  emit Transfer(_from, _to, _tokenId);
  _operators[_from][msg.sender] = false;
  _owners[_tokenId] = _to;
}
```

So we can on a transfer, emit transfer, and this is going to be _from, _to, _tokenId.

```solidity
function mint(uint256 _tokenId) external {
  require(_owners[_tokenId] == address(0), "already minted");
  require(_tokenId < 100, "_tokenId too large");
  // 新添加部分
  emit Transfer(address(0), msg.sender, _tokenId);
  _owners[_tokenId] = msg.sender;
}
```

Okay, another thing that we need to do is when we mint this thing. This is also considered a transfer, because if we mint something but we don't admit an event, then opensea or other marketplaces have no way of knowing that token came into existence, or at least not a very it's very inconvenient for them to find out, so we will also emit a transfer event here, and this will be from address 0 (from address(0) is convention for minting), it will go to msg.sender and the tokenId will be the tokenId that was just created. 

```solidity
/// @dev This emits when the approved address for an NFT is changed or
///  reaffirmed. The zero address indicates there is no approved address.
///  When a Transfer event emits, this also indicates that the approved
///  address for that NFT (if any) is reset to none.
event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

/// @dev This emits when an operator is enabled or disabled for an owner.
///  The operator can manage all NFTs of the owner.
event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
```

Similarly, we have events for approval and approveForAll, so based off of the thing we did in the last video (应该是指前边的内容，这个视频经过他自己剪辑了) .

```solidity
function setApprovalForAll(address _operator, bool _approved) external {
	_operators[msg.sender][_operator] = _approved;
	emit ApprovalForAll(msg.sender, _operator, _approved);
}
```

If we wanted to follow the specification, we also need to specify an ApprovalForAll event and put that whoops and put that inside of this function. So emit approve for all and the owner will, of course, be msg.sender and the operator will just be the operator. So I will delete this, and approved is if the approval was given or not.

```solidity
/// @notice Count all NFTs assigned to an owner
/// @dev NFTs assigned to the zero address are considered invalid, and this
///  function throws for queries about the zero address.
/// @param _owner An address for whom to query the balance
/// @return The number of NFTs owned by `_owner`, possibly zero
function balanceOf(address _owner) external view returns (uint256);
```

Okay, at this point, we've covered almost everything, so we've discussed what these events are. The only thing we haven't looked at is balanceOf which we will get to the next video. The last thing that we're going to look at is the balanceOf function. Now this is rarely used in practice, so I'm not going to go into it in too much detail, but it is helpful to know what it is and what it does. What it does is it counts all nfts assigned to an owner, and this means, if you own token id 5, 10 and 12, then your balance of would be three. If you ask it about the xero address. It's considered invalid and it should throw an exception. Okay, let's implement it now how this will traditionally track. Things is with a mapping that goes from address to un-256, and this would be stored in balances when we mint it we're going to want to increment the balance. For this address, so when it's minted now they own one piece, or at least one more piece than they used to so the balance is incremented. The other time that someone's balance might change is on the transfer from so the person who is sending the nft has their balance decremented and the person receiving the nft has their balance. Incremented no surprises there and so the actual implementation we'll simply check that we're not asking about the xero address and then just return the balances of the address in question. So let's see this in action we will deploy our contract as usable and the address we are using is zero a0. So let's copy that and mint a few nfts for ourselves, we will mint 5, 12 and 10. Our balance of as expected should be 3, and if we conduct a transfer then this should go down. So if we transfer from our own address to a different address and let's transfer number five, we can uh oops, I didn't switch that there we go. Let's do number five and we see that our balance of has gone down and if we look at the recipient, we expect to see a balance of one. 

If we ask for the balance of an address that doesn't have anything, then we will get zero, which is to be expected. We are now ready to dive into the open, zeppelin contract and understand, what's really going on when we first look at the erc 721 nft implementation by open zeppelin there's going to be a lot of unfamiliar stuff at first glance. That's why I wanted to really build out the protocol step by step so that you don't get overwhelmed by seeing a bunch of new stuff here, with the exception of the strings library which we use to convert integers to strings, a lot of this will be unfamiliar, but that's okay, we're going to cover it later. There are two new things that we see here. One is a string, private name and a string, private symbol. These are later paired with getter functions, name and symbol, and these two are part of the extended metadata option for erc 721. And if you look at a nft contract, you will see them being used by etherscan and by other websites, so board ape yacht club is what was set for the name and bayc was the token. In fact, if we were to call those functions over here, let's find name- and we see it is board api club and token or I'm sorry and symbol would be bayc.