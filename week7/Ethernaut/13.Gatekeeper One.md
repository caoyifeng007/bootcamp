Make it past the gatekeeper and register as an entrant to pass this level.

##### Things that might help:

- Remember what you've learned from the Telephone and Token levels.
- You can learn more about the special function `gasleft()`, in Solidity's documentation (see [here](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html) and [here](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#external-function-calls)).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import '@openzeppelin/contracts/math/SafeMath.sol';

contract GatekeeperOne {

  using SafeMath for uint256;
  address public entrant;

  modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
  }

  modifier gateTwo() {
    require(gasleft().mod(8191) == 0);
    _;
  }

  modifier gateThree(bytes8 _gateKey) {
      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), "GatekeeperOne: invalid gateThree part one");
      require(uint32(uint64(_gateKey)) != uint64(_gateKey), "GatekeeperOne: invalid gateThree part two");
      require(uint32(uint64(_gateKey)) == uint16(tx.origin), "GatekeeperOne: invalid gateThree part three");
    _;
  }

  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
    entrant = tx.origin;
    return true;
  }
}
```











参考答案链接：https://medium.com/coinmonks/ethernaut-lvl-13-gatekeeper-1-walkthrough-how-to-calculate-smart-contract-gas-consumption-and-eb4b042d3009

如果想要使一个x满足 uint32(x) == uint16(x)，uint16转为uint32之后的高16位必定是自动填补的0，所以保证uint32的高16位是0就可以了，那么让 x = x & 0x0000FFFF 屏蔽掉了高16位使其全部为0

如果想要使一个x满足 uint32(x) != uint64(x)，uint32转为uint64之后的高32位必定是自动填补的0，要保证高32位不同，那么让 x =  x & 0xFFFFFFFF+0000FFFF 就可保留x的高32位内容

如果想要使一个x满足 uint32(x) == uint16(tx.origin)，满足这一条让 x = tx.origin & 0x0000FFFF 就行了，和第一条重叠了

所以最终的 **bytes8 key = bytes8(tx.origin) & 0xFFFFFFFF0000FFFF;**



现在还在enterGate函数中，马上要执行CALL这个opcode，注意此时remaining gas是7149

![](gasdebug.png)

进入到enter函数中，注意此时remaining gas已经变为我们自己指定的3000了

![](gasdebug1.png)

debug到这里，注意此时opcode是GAS (Get the amount of available gas, including the corresponding reduction for the cost of this instruction) ，所以可以认为在执行gasleft()之前，一共消耗了 3000 - 2748 = 252 gas，也就是说在从进入enter函数到执行gateTwo这个modifier的gasleft()之前一共需要消耗252，如果要计算为8191的整数倍的话就是:

8,191 + 252 = 8,443

![](gasdebug2.png)